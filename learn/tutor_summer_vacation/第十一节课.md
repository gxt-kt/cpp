# ç¬¬åä¸€èŠ‚è¯¾

### å®¹å™¨çš„è¿­ä»£å™¨

è¿­ä»£å™¨çš„æœ¬è´¨æ˜¯ä¸€ç§æŠ½è±¡çš„æ•°æ®è®¿é—®æ¥å£ï¼Œå®ƒæä¾›äº†ä¸€ç§ç»Ÿä¸€çš„æ–¹å¼æ¥è®¿é—®å®¹å™¨ä¸­çš„å…ƒç´ ï¼Œè€Œä¸éœ€è¦æš´éœ²å®¹å™¨çš„å†…éƒ¨å®ç°ç»†èŠ‚ã€‚è¿­ä»£å™¨å¯ä»¥çœ‹ä½œæ˜¯å®¹å™¨å’Œç®—æ³•ä¹‹é—´çš„æ¡¥æ¢ï¼Œå®ƒä½¿å¾—ç®—æ³•èƒ½å¤Ÿç‹¬ç«‹äºå…·ä½“å®¹å™¨ç±»å‹è¿›è¡Œæ“ä½œã€‚

è¿­ä»£å™¨çš„æœ¬è´¨å¯ä»¥é€šè¿‡ä»¥ä¸‹å‡ ä¸ªæ–¹é¢æ¥ç†è§£ï¼š

1. **å°è£…å®¹å™¨çš„å†…éƒ¨ç»“æ„**ï¼šè¿­ä»£å™¨éšè—äº†å®¹å™¨çš„å†…éƒ¨ç»“æ„ï¼Œå°†å…ƒç´ çš„è®¿é—®æ“ä½œå°è£…åœ¨è¿­ä»£å™¨å¯¹è±¡ä¸­ã€‚é€šè¿‡è¿­ä»£å™¨ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥ä¸€ç§ç»Ÿä¸€çš„æ–¹å¼è®¿é—®å®¹å™¨ä¸­çš„å…ƒç´ ï¼Œè€Œä¸éœ€è¦äº†è§£å®¹å™¨çš„å…·ä½“å®ç°ã€‚
2. **æä¾›ç»Ÿä¸€çš„æ¥å£**ï¼šè¿­ä»£å™¨æä¾›äº†ä¸€ç»„é€šç”¨çš„æ“ä½œæ¥å£ï¼Œä¾‹å¦‚è§£å¼•ç”¨æ“ä½œç¬¦ **``*``** å’Œæˆå‘˜è®¿é—®æ“ä½œç¬¦ **``->``**ï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥åƒæ“ä½œæŒ‡é’ˆä¸€æ ·æ“ä½œè¿­ä»£å™¨ã€‚è¿™ç§ç»Ÿä¸€çš„æ¥å£ä½¿å¾—ç®—æ³•å¯ä»¥åœ¨ä¸åŒçš„å®¹å™¨ä¸Šè¿›è¡Œæ“ä½œï¼Œè€Œä¸éœ€è¦é’ˆå¯¹æ¯ç§å®¹å™¨ç±»å‹ç¼–å†™ç‰¹å®šçš„ä»£ç ã€‚
3. **æ”¯æŒè¿­ä»£å™¨ç±»åˆ«**ï¼šè¿­ä»£å™¨é€šå¸¸æ ¹æ®å…¶åŠŸèƒ½å’Œæ€§èƒ½ç‰¹ç‚¹è¢«åˆ’åˆ†ä¸ºä¸åŒçš„ç±»åˆ«ï¼Œä¾‹å¦‚è¾“å…¥è¿­ä»£å™¨ï¼ˆInput Iteratorï¼‰ã€è¾“å‡ºè¿­ä»£å™¨ï¼ˆOutput Iteratorï¼‰ã€æ­£å‘è¿­ä»£å™¨ï¼ˆForward Iteratorï¼‰ã€åŒå‘è¿­ä»£å™¨ï¼ˆBidirectional Iteratorï¼‰å’Œéšæœºè®¿é—®è¿­ä»£å™¨ï¼ˆRandom Access Iteratorï¼‰ç­‰ã€‚ä¸åŒç±»åˆ«çš„è¿­ä»£å™¨æä¾›äº†ä¸åŒçº§åˆ«çš„åŠŸèƒ½å’Œæ€§èƒ½ä¿è¯ï¼Œä»¥æ»¡è¶³ä¸åŒçš„éœ€æ±‚ã€‚
4. **æ”¯æŒè¿­ä»£å™¨è¿ç®—**ï¼šè¿­ä»£å™¨å¯ä»¥é€šè¿‡é€’å¢å’Œé€’å‡æ“ä½œç¬¦è¿›è¡Œç§»åŠ¨ï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥åœ¨å®¹å™¨ä¸­å‰è¿›æˆ–åé€€ã€‚æ­¤å¤–ï¼Œè¿­ä»£å™¨è¿˜æ”¯æŒæ¯”è¾ƒæ“ä½œç¬¦ï¼Œä½¿å¾—æˆ‘ä»¬å¯ä»¥å¯¹è¿­ä»£å™¨è¿›è¡Œæ¯”è¾ƒï¼Œåˆ¤æ–­å®ƒä»¬çš„ç›¸å¯¹ä½ç½®ã€‚

å®ƒå°è£…äº†å®¹å™¨çš„å†…éƒ¨ç»“æ„ï¼Œæä¾›äº†ç»Ÿä¸€çš„æ“ä½œæ¥å£ï¼Œå¹¶æ”¯æŒè¿­ä»£å™¨ç±»åˆ«å’Œè¿­ä»£å™¨è¿ç®—ã€‚é€šè¿‡ä½¿ç”¨è¿­ä»£å™¨ï¼Œæˆ‘ä»¬å¯ä»¥ä»¥ä¸€ç§é€šç”¨çš„æ–¹å¼å¯¹å®¹å™¨è¿›è¡Œéå†å’Œæ“ä½œã€‚

**ç¤ºä¾‹ï¼š**

```cpp
std::vector<int> my_vector(10, 1);
std::vector<int>::iterator it=my_vector.begin();
*it=10;

std::vector<MyStruct>::iterator it2;
it2->value;
*it2;
```

**ä½¿ç”¨è¿­ä»£å™¨éå†vectorç¤ºä¾‹ï¼š**

```cpp
std::vector<int> my_vector(10, 1);
std::vector<int>::iterator it=my_vector.begin();
*it=2;
*(it+5)=10;

for(std::vector<int>::iterator it=my_vector.begin();it<my_vector.end();it++) {
    gDebug(*it);
}
// é€šå¸¸æˆ‘ä»¬è§‰å¾—æ¯æ¬¡æŒ‡å®šè¿­ä»£å™¨ç±»å‹å¤ªç¹çï¼Œéƒ½æ˜¯ç”¨auto
for(auto it=my_vector.begin();it<my_vector.end();it++) {
    gDebug(*it);
}
```

## åœ¨ä¹‹å‰çš„MyNumArrayä¸Šå†™ä¸€ä¸ªè‡ªå·±çš„è¿­ä»£å™¨

```cpp
typedef T* iterator;
T* begin() {
    return data;
};
T* end() {
    return data+size;
};
```

è¿™æ ·ä¹Ÿå¯ä»¥å®ç°

```cpp
for(auto it=aa.begin();it<aa.end();it++) {
  gDebugCol1(*it);
}
```

### å®ä¾‹

æŠŠä¹‹å‰å†™çš„äºŒåˆ†æŸ¥æ‰¾ç®—æ³•æ”¹æˆ`std::vector`ï¼Œæ”¾åˆ°leetcodeå¹³å°ä¸Šè¯•ä¸€ä¸‹

## vectorå­˜æ”¾boolç±»å‹

**ä¸ºäº†èŠ‚çœç©ºé—´**ï¼Œvector`<bool> `åº•å±‚åœ¨å­˜å‚¨å„ä¸ª bool ç±»å‹å€¼æ—¶ï¼Œæ¯ä¸ª bool å€¼éƒ½åªä½¿ç”¨ä¸€ä¸ªæ¯”ç‰¹ä½ï¼ˆäºŒè¿›åˆ¶ä½ï¼‰æ¥å­˜å‚¨ã€‚ä¹Ÿå°±æ˜¯è¯´åœ¨ `vector<bool> `åº•å±‚ï¼Œ**ä¸€ä¸ªå­—èŠ‚å¯ä»¥å­˜å‚¨ 8 ä¸ª bool ç±»å‹å€¼**ã€‚

**``vector<bool>``**ä¸­çš„å¸ƒå°”å€¼ä¸èƒ½è¢«å–åœ°å€ã€‚è¿™æ˜¯å› ä¸ºæ¯ä¸ªå¸ƒå°”å€¼å®é™…ä¸Šæ˜¯å­˜å‚¨åœ¨ä¸€ä¸ªä½ä¸Šçš„ï¼Œè€Œä¸æ˜¯ä¸€ä¸ªç‹¬ç«‹çš„å­—èŠ‚ã€‚è¿™æ„å‘³ç€æ— æ³•è·å–ä¸€ä¸ªå¸ƒå°”å€¼çš„æŒ‡é’ˆï¼Œä¹Ÿæ— æ³•åœ¨ç®—æ³•ä¸­ä½¿ç”¨æŒ‡é’ˆæ“ä½œã€‚

ä½œä¸ºå¯¹æ¯”ï¼Œ`std::vector<int>`å­˜å‚¨çš„å†…å®¹æ˜¯å¯ä»¥å–åˆ°åœ°å€çš„

```cpp
std::vector<int> aa{1,2,3};
auto type=&aa[0];
gDebug(TYPE(type));
type++;
gDebug(*type);
```

***

## ç±»çš„æˆå‘˜å¸¸å‡½æ•°

ğŸ’¡**å¸¸å‡½æ•°å’Œæ™®é€šå‡½æ•°æ˜¯å¦æ„æˆé‡è½½ï¼Ÿ**

å¦‚æœæ„æˆé‡è½½ï¼ŒåŒºåˆ†å®ƒä»¬çš„æ¡ä»¶æ˜¯ä»€ä¹ˆï¼Ÿ

ä¸ºä»€ä¹ˆè¦è¿™ä¹ˆè®¾è®¡ï¼Ÿ

```cpp
struct MyClass {
  int a[10];
  MyClass() {}
  int& operator[](int index) {
    gDebug("[]");
    return a[index];
  }
  const int& operator[](int index) const {
    gDebug("[] const");
    return a[index];
  }
};

int main(int argc, char *argv[]) {
  MyClass aa;
  aa[10]=5;
  const MyClass bb;
  bb[10];
  return 0;
}
```

***

## ä½¿ç”¨ {} å¯¹ç±»è¿›è¡Œåˆå§‹åŒ–ï¼ˆstd::initializer_listï¼‰ç°ä»£c++

è®°ä¸è®°å¾—ä¹‹å‰æœ‰è®²è¿‡ï¼ˆï¼‰å’Œ{}åˆå§‹åŒ–æ˜¯ä¸åŒçš„è¡Œä¸ºã€‚

æˆ‘ä»¬æœ‰ä¸€ä¸ªéœ€æ±‚ï¼Œåˆå§‹åŒ–vectorçš„æ—¶å€™å¸Œæœ›åƒæ•°ç»„ä¸€æ ·ï¼Œä¸æŒ‡å®šå®ƒçš„å¤§å°ï¼Œç›´æ¥æ ¹æ®è¾“å…¥å‚æ•°çš„å†…å®¹è‡ªåŠ¨åˆ¤æ–­å¤§å°

ä¹Ÿå°±æ˜¯å’Œ`int a[]={1,2,3}`ä¸€æ ·

`std::vector<int> a{1,2,3};`å°±æ˜¯åˆå§‹åŒ–ä¸€ä¸ªaï¼Œå¤§å°æ˜¯3ï¼Œåˆ†åˆ«ä¸º1,2,3

è®©æˆ‘ä»¬æ¥çœ‹çœ‹é‚£`std::initializer_list`çš„**æºç **ï¼š

```cpp
template<class _E>
    class initializer_list
    {
        public:
        typedef _E 		value_type;
        typedef const _E& 	reference;
        typedef const _E& 	const_reference;
        typedef size_t 		size_type;
        typedef const _E* 	iterator;
        typedef const _E* 	const_iterator;

        private:
        iterator			_M_array;
        size_type			_M_len;

        // The compiler can call a private constructor.
        constexpr initializer_list(const_iterator __a, size_type __l)
            : _M_array(__a), _M_len(__l) { }

        public:
        constexpr initializer_list() noexcept
            : _M_array(0), _M_len(0) { }

        // Number of elements.
        constexpr size_type
            size() const noexcept { return _M_len; }

        // First element.
        constexpr const_iterator
            begin() const noexcept { return _M_array; }

        // One past the last element.
        constexpr const_iterator
            end() const noexcept { return begin() + size(); }
    };
```

**ä½¿ç”¨æ—¶éœ€è¦åŠ ä¸Šå¤´æ–‡ä»¶` #include <initialize_list>`: **

```cpp
void Fun(std::initializer_list<int> list) {
  for(auto it=list.begin();it!=list.end();it++) {
    gDebug(*it);
  }
}
```

### ç»™æˆ‘ä»¬è‡ªå·±çš„`MyNumArray`åŠ ä¸Š`initialize_list`ï¼Œä½¿å®ƒæ”¯æŒä½¿ç”¨{}è¿›è¡Œåˆå§‹åŒ–

```cpp
MyNumArray(std::initializer_list<T> list) {
    size = list.size();
    data = new T[size];
    const auto& it = list.begin();
    for (int i = 0; i < size; i++) {
        data[i] = *(it + i);
    }
}
```

***

## unorder_mapçš„ä½¿ç”¨

åŒ…å«å¤´æ–‡ä»¶ï¼šé¦–å…ˆï¼Œä½ éœ€è¦åŒ…å« **``<unordered_map>``** å¤´æ–‡ä»¶ã€‚

```cpp
#include <unordered_map>  
```

å®šä¹‰å’Œåˆå§‹åŒ– **``unordered_map``**ï¼šå®šä¹‰ä¸€ä¸ª **``std::unordered_map``** å¯¹è±¡ï¼Œå¹¶ä½¿ç”¨é€‚å½“çš„é”®å’Œå€¼ç±»å‹è¿›è¡Œåˆå§‹åŒ–ã€‚

```cpp
std::unordered_map<KeyType, ValueType> myMap;  
```

å…¶ä¸­ï¼Œ**``KeyType``** æ˜¯é”®çš„ç±»å‹ï¼Œ**``ValueType``** æ˜¯å€¼çš„ç±»å‹ã€‚

ä½ è¿˜å¯ä»¥ä½¿ç”¨åˆå§‹åŒ–åˆ—è¡¨æ¥åˆå§‹åŒ– **``unordered_map``**ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```cpp
std::unordered_map<KeyType, ValueType> myMap = {  
    {key1, value1},  
    {key2, value2},  
    // ...  
};  
```

**æ’å…¥å…ƒç´ **ï¼šä½¿ç”¨ **``insert()``** å‡½æ•°æˆ– **``[]``** è¿ç®—ç¬¦å‘ **``unordered_map``** ä¸­æ’å…¥å…ƒç´ ã€‚

```cpp
myMap.insert(std::make_pair(key, value)); // ä½¿ç”¨ insert() å‡½æ•°  
myMap[key] = value; // ä½¿ç”¨ [] è¿ç®—ç¬¦  
```

è®¿é—®å…ƒç´ ï¼šä½¿ç”¨ **``[]``** è¿ç®—ç¬¦æ¥è®¿é—® **``unordered_map``** ä¸­çš„å…ƒç´ ã€‚

```cpp
ValueType value = myMap[key];  
```

ğŸ’¡å¦‚æœæŒ‡å®šçš„é”®ä¸å­˜åœ¨äº **``unordered_map``** ä¸­ï¼Œä½¿ç”¨ **``[]``** è¿ç®—ç¬¦å°†ä¼šæ’å…¥ä¸€ä¸ªå…·æœ‰é»˜è®¤å€¼çš„å…ƒç´ ã€‚

åŒæ ·ä½œä¸ºåŒºåˆ†ï¼Œä½¿ç”¨`at(index)`å¦‚æœä¸å­˜åœ¨ä¼šæŠ›å‡ºå¼‚å¸¸ï¼ˆæŠ¥é”™ï¼‰

**æŸ¥æ‰¾å…ƒç´ **ï¼šä½ å¯ä»¥ä½¿ç”¨ **``find()``** å‡½æ•°æ¥æŸ¥æ‰¾ **``unordered_map``** ä¸­çš„å…ƒç´ ã€‚**``find()``** å‡½æ•°è¿”å›ä¸€ä¸ªè¿­ä»£å™¨ï¼ŒæŒ‡å‘æ‰¾åˆ°çš„å…ƒç´ ï¼Œå¦‚æœå…ƒç´ ä¸å­˜åœ¨ï¼Œåˆ™è¿”å› **``end()``** è¿­ä»£å™¨ã€‚

```cpp
auto it = myMap.find(key);  
if (it != myMap.end()) {  
    // å…ƒç´ æ‰¾åˆ°  
    ValueType value = it->second;  
} else {  
    // å…ƒç´ ä¸å­˜åœ¨  
}  
```

**åˆ é™¤å…ƒç´ **ï¼šä½¿ç”¨ **``erase()``** å‡½æ•°æ¥åˆ é™¤ **``unordered_map``** ä¸­çš„å…ƒç´ ã€‚

```cpp
myMap.erase(key); // åˆ é™¤æŒ‡å®šé”®çš„å…ƒç´   
```

éå†å…ƒç´ ï¼šä½ å¯ä»¥ä½¿ç”¨èŒƒå›´å¾ªç¯æˆ–è¿­ä»£å™¨æ¥éå† **``unordered_map``** ä¸­çš„å…ƒç´ ã€‚

**ä½¿ç”¨èŒƒå›´å¾ªç¯ï¼š**

```cpp
for (const auto& pair : myMap) {  
    KeyType key = pair.first;  
    ValueType value = pair.second;  
    // ä½¿ç”¨ key å’Œ value è¿›è¡Œæ“ä½œ  
}  
```

**ä½¿ç”¨è¿­ä»£å™¨ï¼š**

```cpp
for (auto it = myMap.begin(); it != myMap.end(); ++it) {  
    KeyType key = it->first;  
    ValueType value = it->second;  
    // ä½¿ç”¨ key å’Œ value è¿›è¡Œæ“ä½œ  
}  
```

### ä½¿ç”¨ç¤ºä¾‹

```cpp
std::unordered_map<std::string, int> aa = {
    {"ming", 22},
    {"hong", 40},
    {"lihua", 120},
    {"zhangsan", 3},
};
gDebug(aa.size());
auto ret = aa["ming"];
gDebug(ret);
aa["min"] = 50;
gDebug(ret);
auto ret2 = aa.at("min");
gDebug(ret2);
auto iffind = aa.find("ming");
if (iffind == aa.end()) {
    gDebugCol3("not find");
} else {
    gDebugCol1("find");
    gDebug(iffind->first);
}
```

### å¾ˆæœ‰æ„æ€çš„å°é¢˜ç›®

![image-20230811180923773](https://raw.githubusercontent.com/gxt-kt/picgo_pictures/master/image-20230811180923773.png)

ä»£ç å¡«ç©ºï¼š

```cpp
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        
    }
};
```

